---
layout: post
title: '淘宝秒杀脚本'
tags: [CS]
categories: [Chinese]
comments: true
---



开始做一件事情的起因往往很简单，但过程本身的意义才决定了你能够走多远。

这篇博文不讨论使用脚本抢券的行为是否合理，而只是从编写一个秒杀脚本的角度出发，探讨其中的技术细节、可行性以及后果。

博文的代码在[这里](https://github.com/ouromoros/secondkiller)。

## 初步的设想

在决定好要写一个秒杀脚本之后，我们首先需要确定秒杀一个商品所需要的步骤，而这就需要在网站中实际进行操作来对流程进行了解，如果以后程序需要实现其它网站的秒杀功能则需要重新进行调查，在之后设计程序时我们也要考虑到这一点。淘宝中秒杀的商品在到时间之后和普通的商品的购买流程没有区别，因此测试时下订单的功能也可以使用普通商品进行测试，秒杀一个商品的步骤大致如下：

```
登录 -> 等待秒杀开始 -> 从商品界面点击立即购买 -> 从订单界面点击确认订单
```

在完成下订单之后就算抢到了商品，接下来只需要人工完成支付就万事大吉。

由于都是在网页端进行操作，因此我们想到可以使用一个http库来模拟网页的请求，`requests`库就是一个很好的选择，在最理想的情况下，我们只需要在到时间之后不停地向服务器发送确认订单的请求，接下来就祈祷服务器发善心满足我们的祷告。但很遗憾的，淘宝采取了一些措施来限制这种操作，首先的问题就是即使使用在浏览器中正常登录得到的cookie也无法进行登录之后的操作，淘宝服务器可能还做了一些request headers之类的检测，这方面我没有再深入探究，因为第二个问题更无法解决。第二个问题是淘宝的确认订单界面是一个javascript生成的动态页面，因此简单的http库是无法完成确认订单这一动作的，我们只能转向另一种方法。

除了模拟http请求以外，我们还可以使用`selenium`来操作浏览器进行网页上的自动操作，而这基本就是万能的了，因为使用`selenium`和webdriver控制浏览器几乎和正常浏览差不多（有时网页依旧可以通过某些方式来检测到你使用了`selenium`，不过一般来说问题不大，可以解决），`selenium`可以解决除了验证码或者滑块之外的所有问题，而缺点是运行一个浏览器实例消耗的资源较多，不能并发运行很多个实例。

就像上面说到的，`selenium`并不能解决验证码的问题，而秒杀过程中很重要的一步就是首先要登录账号。由于淘宝登录机制很难使用常规的手段通过，而cookie也无法长期使用，因此只有每次使用脚本时都手动登录一次网站，使用二维码的方式，也并不会很繁琐。

## 程序的结构

`selenium`是一个非常麻烦的库，而chromedriver也有很多麻烦的地方，需要一些莫名奇妙的配置以及奇怪的地方。一些和`selenium`相关的繁琐的细节以及为了方便而编写的可以复用的函数都放在了`driver_util.py`文件当中。

由于网页操作中常常遇到不可预料的错误，因此和网页操作相关的操作都要放在`try`当中，和淘宝的具体细节相关的代码大部分都在`taobao.py`当中。

`main.py`中为单个浏览器实例中单个窗口请求的程序代码。

`multi-maim.py`中为单个浏览器实例中多个窗口同时请求的程序代码。

这样明确地划分代码自然是有好处的，但是我发现在刚开始写代码的时候往往没法对整体程序有一个清晰的认知，特别是在像我这次这样使用`selenium`这一个不熟悉的库来实现一个没有实现过的功能的情况下就更困难了。因此写程序的开始可以先将代码都在一个`main`文件中编写，在这个文件变得有些大且可以看出代码有一些功能上的划分时再将部分代码移到一个新文件中去。

## selenium与webdriver

webdriver有很多tricky的地方，网上的文档也不算完全，由于这部分其实较为麻烦，因此将它放入了一个函数当中，具体的初始化webdriver的代码可以在`get_driver`函数中找到，这里就讲一下我们的需求。

由于我们需要秒杀商品，因此webdriver的默认模式，即如`get`等函数要等到网页加载完毕才返回的模式是不行的，我们需要在按钮加载出来并可以点击的第一时间发出请求，因此需要把`driver`设为非阻塞的模式。

由于Chrome浏览器渲染也需要时间，但对我们来说显示网页是多余的，我们只需要浏览器进行加载资源、执行js的操作，因此加入`--headless`的参数让浏览器在后台运行，没有gui界面。

## Scheduler

出于浏览器中网页可能会到处跳转、一个操作（可能失败、可能出错）的结果很难预判，为了简化程序逻辑，在执行的过程中，我们将网页的执行比作一个状态机，每次根据目前所处的url（或者其它内容）判断当前的状态之后执行所对应的操作，因此整个程序的执行就是一个`while`循环中，我们不停地判断当前的状态并执行对应的操作。

我们将这个逻辑抽象为了一个`Scheduler`的class当中。

## Multi-Scheduler

很自然地，对于一个秒杀软件我们需要能*多线程*地去请求网页，但浏览器没打开一个实例就需要登录一次，十分麻烦，因此我们就想在一个Chrome实例中打开多个标签页来同时发出多个请求。但这时出现了一个问题，webdriver只能模拟人的操作去操作浏览器，而不能直接去控制某一个标签页的操作，如果需要对某个标签页进行操作，则需要先使用`driver.switch_to.window`切换到标签页，再使用`driver.get`等操作。前面说到，`driver`已经设为了非阻塞模式，因此其实我们只需要在一个循环中不停地切换标签页、判断条件、执行操作即可，由于命令是非阻塞的，因此相当于是并发执行。

不过在实现中我更进了一步，使用了`Thread`来实现对每个标签页进行操作，每个线程中的`while`循环运行时会先获取一个全局的锁，然后执行判断条件与操作，最后释放锁，并且使用`time.sleep(0)`表示线程切换。这样的话就是隐式地将调度的问题交给了线程处理，如果某个标签页在操作之后需要等待的话实现起来也很直接，在释放了锁之后调用`time.sleep()`即可。

## 总结

在实际使用秒杀之后发现，`Scheduler`的使用其实是一把双刃剑。淘宝反爬虫机制很多也很复杂，而`Scheduler`是一个状态机的形式，但其中每个状态没有一个内部状态，因此如果要应对复杂的反爬虫机制，我们很可能不得不去修改`Scheduler`，引入一些特殊情况或者状态，但这就与最初的想法背道而驰了。还好，我的目的并不是完全攻破淘宝的机制并大规模使用脚本获利，因此不用再关心这些问题，只要能用就行。~~可惜最后还是抢不到券，一定是网络的原因，到服务器的延迟太高了，绝对不是程序的问题。~~
