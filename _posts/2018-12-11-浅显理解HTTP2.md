---
layout: post
title: 浅显理解HTTP/2
tags: [CS, Network]
categories: [Chinese]
---
*不久之前HTTP/3横空出世，那么现在是时候简单了解一下HTTP/2了。*

本文假定读者已经有HTTP、TCP/IP等网络基础。本文只做最简单的介绍与总结，若需要稍微更详细一些的信息，可以在选择性地阅读本文之后看[这里](https://developers.google.com/web/fundamentals/performance/http2/)。

# HTTP/2没有什么

对一般的Web开发者来说，HTTP/2和HTTP/1几乎没有什么不同，GET、POST等方法依然没变，404等状态码没有变化，甚至各种HEAD也没有变化...简单来说，如果你不开发服务器的话，那么HTTP/2呈现的内容和HTTP/1几乎是一样的。

这也是可以理解的，原来的HTTP并没有让我们感觉有什么不方便，也没有什么需要用很别扭的方法实现的功能，那为什么要改变它呢？或许我们可以改一下状态码的表示方式，或许我们可以重新定义方法的形式，使它更加“优雅”一些，但是谁会那么无聊去做这种不讨好的事情呢？这是注定会失败的，没有人会仅仅因为更加“优雅”和减少一点微不足道的overhead而采用你的协议。

HTTP/2并不是一个功能性的更新，它只是针对现代Web的需要重新设计了底层的传输方式与数据表示，对网络性能进行了优化。所以对大部分人来说，HTTP还是那个HTTP，只有少部分人（比如服务器开发者）需要操心它的变化。

# HTTP/2之前

我们先回想一下，在HTTP/0.9的设计中，文档的传输是以最简单的请求/回应方式进行的：当我们每需要获取一个文档时就和服务器建立一个TCP连接，发送请求，接受数据。它十分简单和易于实现，因此很快就普及开了。

但它也具有很多缺点，而这些缺点随着网络的发展和我们需求的升高而逐渐暴露了出来，因此后来出现了HTTP/1.1、HTTP/1.2，Keep-Alive的引入解决了每请求一个文档都要建立一个新的TCP连接所产生的overhead，Chunk使我们能够发送大小可变的数据包，一切似乎都渐渐变好了。

但我们终究无法一直保持向前兼容，Header有大量冗余信息、要同时请求多个文件依然需要建立多个TCP连接...最讨厌的事情莫过于我们明知道这些问题存在，却依然对它们无可奈何。于是HTTP/2出现了，它以更好的方式解决了这些问题，而代价是不再和HTTP/1兼容。

# HTTP/2改变了什么

HTTP/2最大的变化在于一个客户端仅与一个服务器建立一个TCP连接，其中数据的传输采用“帧”的方式，“帧”可以理解为一个包，多个有顺序的包组成一个“数据流”，一个数据流往往代表一个文件（e.g. html、js、css）。一个连接中可以有多个数据流存在，我们可以将其理解为一个**建立在TCP之上的TCP**，每个帧都包含其属于哪个数据流的信息，因此不同数据流的帧可以交错发送，然后由另一端对其进行dispatch，而且服务器和客户端可以同时向对方发送数据。这是最重要的变化，其它的优化都是基于这一点进行的。

当我们请求一个网页时，常常也需要同时请求其包含的资源（e.g. js、css、img），而这需要客户端在收到该网页之后再次发出请求。这看起来很符合直觉，但若深入思考一下我们可以想到，在服务器向客户端发送第一个网页时就应该知道客户端之后“很可能”会需要相应的资源了。因此在HTTP/2中服务器可以向客户端主动推送它认为客户端需要的资源，而不需要客户端主动发出请求，这相当于缩短了一个RTT的延迟。

HTTP/1中Header的overhead问题也终于得到了解决，HTTP/2使用了HPACK的压缩算法，使我们不必再在每个请求/回应中包含那些一模一样的Head了，大大减少了overhead。客户端和服务器都需要维护一个表，应该比较类似于lzw算法，基于客户端与服务器所有之前的请求/回应对当前请求/回应进行压缩，这也是我们将所有东西包含在一个TCP连接之后才能做到的（这样才能一起处理）。

之前将HTTP/2比喻为一个*基于TCP的TCP*不是没有道理的，在做了“流”的抽象之后，HTTP/2也引入了流的优先级、依赖树以更好地进行优化（毕竟HTTP相对于TCP能对它自身进行更好的优化），它甚至还引入了Flow Control，就差重新实现一个协议了（伏笔）。

# 后话

可以看出来，HTTP/2解决的主要是HTTP最初设计时没有考虑到的问题，在HTTP被发明出来的时候网络还很原始，我们不可能要求设计者在当时就考虑到我们现在面临的性能瓶颈，因此标准的更新是必然的。

我们可以看到，HTTP/2所做的优化一大部分都是在网络传输层上做的优化，且基本上是在TCP上实现了自己的网络协议，那么我们是否可以做的更好呢？答案是肯定的，TCP适合于长时间、持续的数据传输，而并不是很适合于HTTP这样短促的数据传输，因此理想情况下我们可以在IP协议上实现一个专用于HTTP的协议，从而避免TCP的overhead。这个方案十分具有吸引力，但因为NAT的存在却是几乎不可能实现的，NAT的大量使用将TCP与UDP协议“固定”了下来，使得所有新的协议都只有建立在这两种协议之上，而不能再在IP层上开发新的协议。

不过我们依然在UDP上实现自己的协议，HTTP/3就是这样做的。虽然不得不接受UDP的overhead这一点十分可惜，但生活依然要继续，我们在UDP上开发了QUIC协议，它专为HTTP的使用情景设计，比TCP的表现要好得多。HTTP/3原本的名字就是HTTP Over QUIC，和它名字所暗示的一样，除了底层使用QUIC协议以外，它相对于HTTP/2并没有太大的差别。

未来的Web还会有新的变化，那么新的协议也会随之被设计出来适应新的需要，你可以成为设计者，也可以是跟随者，但不可能固步自封而不被淘汰。
