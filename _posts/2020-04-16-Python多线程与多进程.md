---
layout: post
title: 'Python多线程与多进程'
tags: [CS, Python]
categories: [Chinese]
comments: true
---
多线程与多进程这两个概念的区别在各种地方已经写烂了，但是在实际编程的过程之中对这两者的使用却依然有一些较为subtle的地方需要注意，这里就从Python的角度出发对其进行探讨。

# Python的GIL机制

对每一个语言来说，在引入了多线程之后就必然需要面临线程之间的同步问题，这并不仅仅指应用中的同步，还有语言runtime中对内部数据结构的同步和管理。现代的编程语言或多或少都是带有一定的runtime的（甚至包括C！），在runtime中往往会完成资源的初始化、对程序错误的处理、最后资源的清理等底层的工作，而垃圾回收（garbage collection）机制大概是其中最著名和应用广泛的feature了。

由于runtime中对各种数据的管理实际上是较为复杂的，而多线程的引入不仅会使其容易出错，而且即使使用各种同步方法（锁、原子操作）实现了并行运行的能力，也会大大降低运行的效率，因为很多时候虽然并不会发生冲突但cpu依然会运行那几条原子操作的指令（较慢）。由垃圾回收机制举例子，Python使用的是reference counting的方法，因此对于每个变量实际上是维护了一个reference count的，每当一个变量脱离了运行范围之后就会将其减1，本来这是一个十分简单的事情，但当出现多线程并行运行的时候该怎么办呢？若在每次减count的时候都做一个同步操作则会大大影响程序运行速度，因此是不可取的。

gc机制只是一个例子，实际上为了规避多线程并行访问数据的问题，又为了维持源代码的清晰简单（有点像借口），Python只提供了一个假的多线程机制，直接用了一个全局锁（GIL）保证了任何时间只有一个线程在运行，这样的话就不存在并行运行的问题了。但这样的话就造成了Python程序在多核机器上也和单核机器的性能差不多，不过可能对Python来说它自己的性能本来就比较无所谓吧，而且大部分应用的瓶颈都不在计算速度上，所以也没什么关系。如果实在有利用多个核的需求的话就可以考虑使用multiprocessing的多进程机制（问题较多），或者去调用C++的并行实现的库（Python的科学计算库应该都是这样做的）。

# 多线程还是多进程

Python本身提供了多进程和多线程的方法，其中多线程已经讲过了，是个虚假的只能在一个核上运行的多线程，不过对于Web服务器之类的IO bound的应用来说问题也不是很大，只有compute-intensive的应用才需要考虑最大限度利用多核算力的问题。

一般来说在Python里面需要利用多核的话就只能使用Python的multiprocessing库，使用这个库首先需要注意其启动新进程的方法。从Python的官方文档来看主要分了`spawn`和`fork`两种，其中`spawn`方法就相当于重新启动了一个Python程序并运行你给的函数，而`fork`方法是只能在Linux上使用的，其实现应该类似于直接调用`fork()`之后然后就运行给定的函数。可以看出`spawn`方法比较接近我们所想的启动一个新进程的方法，而`fork`创建的进程由于继承了文件描述符等信息且没有进行任何清理操作，实际运行中可能会出现一些问题，官方文档特地提到了与多线程结合使用时`fork`可能会有问题，不过就没有更多的描述了。`fork`方法存在的意义在于它非常快（这个原因就和Linux系统内部实现有关了），如果你十分确定`fork`不会造成诸如资源泄露之类的问题的话那么可以尽管使用它，而更为保险的方法则是使用`spawn`。

另外要提到的就是虽然对于IO bound的程序可以用多线程，不过很多时候这也不是最优解，因为一个Python的线程实际上也对应了一个系统的线程，但系统的线程在某种意义上也是比较*重*的，在Linux当中线程的实现和进程几乎是相同的，从某种意义上来说线程只相当于“轻量级”的进程。就之前提到的Web服务器的问题，更好的选择是使用诸如`gevent`这样的轻量级线程库，这种线程库就完全是由库在管理，由于不涉及到系统调用占用的资源也很少，而且不占用系统资源，因此可以支持同时存在非常多的“线程”。

# 后记

在查阅Python的多线程与多进程相关资料的时候再次认识到了，虽然对于较为基础的知识网上的资料较多，但在涉及到了操作系统、编程语言内部实现相关这类较为“偏门”的东西时资料却又很少了，目前来看一般搜索的时候如果StackOverFlow上都找不到的话基本上就再找不到更好的资料。Python中对于进程操作相关的东西从很大意义上已经不只是其语言本身的事情，而是和操作系统更相关，它所提供的方法基本上只能算作是一个接口，如果需要完全掌控的话就需要从操作系统本身的行为出发来调研，可能这也是计算机基础的重要性吧，无论高级编程语言如何尝试去封装底层的细节，在牵涉到效率以及一些实际场景时，我们却总又要回到底层去才能将其实现理解的更为透彻，从而写出更符合我们所想的程序。
