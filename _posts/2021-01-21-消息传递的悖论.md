---
layout: post
title: '消息传递的悖论'
tags: [CS]
categories: [Chinese]
comments: true
---

最近在着手写一个以数据库/消息队列为存储层的[任务调度客户端](https://github.com/ouromoros/oscheduler)，在编写任务消费的时候想要实现有且仅有一次（exactly-once）的特性，避免重复执行任务和丢失任务的情况发生。和分布式系统中会遇到的大多数问题相同，这里面也有各式各样的edge-case需要考虑，但在思考了一番之后却发现这是个几乎不可能解决的难题，随即查阅资料证实了我的想法：在不可靠的环境中exactly-once的消息传递是不可能实现的。

## 两军问题（Two General's Problem）

如果认真学习过计算机网络的话，那么就应该知道经典的两军问题：将军A和将军B需要约定一个会军的地点，这是一个十分重要的信息，如果他们没有达成共识的话（到约定的时间只有一方到达指定地点）这场战争就会失败，他们需要互相确认对方收到了信件并会如期到达约定的地点，但同时他们之间传信的信使却是不可靠的（可能被敌人抓到），这里就出现了问题，两个将军要如何确认对方会到达指定的地点呢？

我们先审视一下可能的策略：由将军A送出一个信使向将军B告知要会军的地点，然后在指定时间去该地点会军。这里有一个问题，将军A要如何确认信使在路上没有被敌人抓到且将军B收到了信件呢？如果按这个策略来的话，很有可能到时候就只有将军A到了指定的地点而将军B没有到（没有收到消息），导致战争的失败。

![](/assets/img/1/one_send.png)

很自然的，我们会想到一个改进的策略：将军A首先送出一个信使告诉将军B要会军的地点，然后将军B再送出一个信使告知将军A收到了消息。这个策略乍看之下没有问题，但我们注意到第二个信使实际上也是不可靠的（可能被敌人抓到），那么就可能出现这样的情况：将军A送的信使到达了将军B处，而将军B回复将军A的信使却丢失了，这时将军B并不知道信使已经丢失于是去了会军地点，而将军A这时无从得知信使是否到达将军B处，于是没有前往指定地点，最终导致了战争的失败。

![](/assets/img/1/one_reply.png)

那么可不可以由将军A再送出一个信使告诉将军B他收到了将军B的回复呢？洞察力敏锐的你想必也注意到了，这样做的本质和上一种做法并无区别，当最后一个信使丢失时，将军B无从得知将军A是否收到了他的回复，于是不会前往指定地点（从B的角度上来说将军A没有收到他的消息所以也不会前往该地点），从而会导致最后只有将军A到达指定地点的情况。类比下去，我们可以得出结论，因为*确认回复*的动作本身就有可能丢失，因此没有绝对安全的方法解决两军问题。

![](/assets/img/1/more_reply.png)

两军问题的本质是最后回复的一方无法确认对方是否收到了回复，从而导致另一方也无法确认对方是否回复了自己的消息，只要消息的传递是不可靠的，那么就会存在最后一次回复丢失的情况，导致A和B对状态的认知产生偏差——A（最后一次发送消息的一方）假设对方已经收到了自己的回复，而B则无法确认A是否收到了自己的消息。

## 至少一次和至多一次（at-least-once and at-most-once）

在任务调度的问题上，问题表现出来是这样的：A是任务调度的系统，B则是消费者，如果要实现有且仅有一次（exactly-once）的特性，那么A和B必须就B是否消费了消息达成一致，最朴素的方法是A先发送消息给B，然后B发送一个回复给A代表消息已经消费了，然后流程结束。一切似乎没有问题，但我们又注意到，B发送给A的回复是可能丢失的！在回复丢失的情况下，A无从知道B是否成功消费了消息，于是只能做出它在该情况下唯一可以做的一件事——重试发送消息，从而打破了我们希望实现的有且仅有一次（exactly-once）的特性。

在这样具体的场景下可能会有人问这样的问题：回复丢失了没有关系啊，由B重新发送回复就可以了。那么问题来了：B如何知道自己发送的回复丢失了呢？我们又回到了两军问题的悖论，A和B永远无法知道最后一次发送的消息是否成功抵达了对方。

我们再来审视从A的角度上来看可以做什么，在A发出消息的最后一个字节时，他可以等待B的回复——若没有收到回复则重新发送消息，这样便实现了至少一次（at-least-once）的特性，因为只有A收到B确认消息已经消费完成之后才会停止发送；或者A也可以选择这样一种策略，无论是否收到了B的回复都不再重新发送消息，这就实现了至多一次（at-most-once）的特性，因为发送者只发送了一次消息，那么接收者也至多可以收到这一条消息。

实际上，这两种策略实际上已经是A所能采取策略的全集了，也就是说至少一次（at-least-once）和至多一次（at-most-once）之间只能二选一，其交集为零，同时兼有两个特性的实现有且仅有一次（exactly-once）的策略是不存在的。

![](/assets/img/1/strategy.png)
消息系统的策略集
{:.figcaption}


## 实际场景中的有且仅有一次（exactly-once）

在消息系统中发送有且仅有一次消息是不可能的，但在实际场景中我们经常会有一些十分重要的需要仅执行一次的操作，如银行账户操作这样十分重要的任务，无论是至少一次（到底操作成功没有？）还是至多一次（怎么一下转了两次帐？）都是无法满足我们要求的，我们希望的是它执行有且仅有一次，如果这都不能保证的话那网上银行就要乱套了。很显然目前所有的金融系统都在正常运转当中，因此这个问题是可以解决的。

在实际场景中我们往往让消息系统实现至少一次（at-most-once）的特性，然后接收方（B）则需要保证操作的幂等性（idempotence），即使有重复的消息发送过来处理后的结果也应当和只有一个消息处理后的结果相同，一般来说这通过赋予消息一个独一无二的ID来实现——B每次处理消息时将其ID记录下来，若在处理消息前B发现这个ID之前已经处理过的时候就可以不再重复执行相同的操作了。

描述了解决方法之后我们不禁思考，为什么呢？为什么在B处进行简单的重复性判断就可以解决这个问题，但消息系统本身却无法做到有且仅有一次（exactly-once）的消息传递，他们的本质有什么区别？实际上，在实际的解决方法中我们假设了B可以原子性的（atomically）同时处理消息和将其ID记录下来，这一般通过数据库的事务来实现（同时更新表和将ID记录到一个地方），这样就可以避免重复消费相同的消息，但在消息系统中我们却无法原子性的去做任何事情，要么A将消息发送给B，要么B将消息发送给A，而这两件事情都是不可靠的，我们不可能实现原子性的A发送消息给B并且B发送回复给A的操作，即只有两种情况——要么A发送消息给了B且B也成功回复了A，要么A的消息没有抵达B且B也没有回复A，永远都存在第三种情况——A发送消息给了B但B的回复却在丢失了的情况，这就是不确定性的根源。

## More

经典的TCP协议中对两军问题也给出了自己的解——最后发送回复的一方（B）通过适当长的超时时间来补偿对方没有收到自己回复的情况，这样当对方重试的时候自己可以再次发送回复并希望对方可以收到这个回复。自然，TCP并没有彻底解决这个问题，若B的回复丢失，且A给B发送的回复也一直丢失导致时间超过了B的超时时间，就会造成这样的情况：B以为超时时间已经过了还没有收到A的重试请求于是认定A收到了自己的回复并愉快的关闭了连接，但A还在傻傻的继续重试发送并坚信自己会等到回复，结果就是对A来说始终不敢关闭连接......当然，这样的话会产生非常打的隐患，因此在实际场景中A在这个时候也设置了一定的超时时间，如果在一段时间的尝试中后都没有得到B的回复，那么A也会干脆的把连接关掉，虽然最后一个消息不一定送过去了，但至少大家都从这个阴影中走了出来。
