---
layout: post
title: GSoC总结
tags: [life]
categories: [Chinese]
comments: true
---
上上上周收到了GSoC的T恤，算是正式标志了这次GSoC经历的结束。本来早就有就此写一篇博客的想法，但基于各种原因迟迟没有动手，现在也算是有始有终吧。

# Workflow

参加GSoC的收获之一就是借此机会熟悉了git的操作与向开源项目做贡献的流程，刚开始还没有目标时对许多开源项目都做了了解，目前来看要在提交一个patch的流程大致是这样的（以Github为例）：

1. 提交一个issue，描述要解决的问题。（可选）
2. 从当前master分支下新建一个branch，在这上面进行自己的工作。
3. 将新的branch上传到自己fork的repo上。（如果还没有就去fork一个）
4. 向原repo提交一个pull request，（引用之前创建的issue，）在里面添加必要的描述。
5. 等待别人的code review，若有需要改动的则在该branch上直接改动，再重复这一步。
6. 大家都表示这个代码没有问题，然后只要等待代码合并到主分支里就行了。

当然根据情况这个workflow也有变化，比如说有的pull request有多人参与，当改动比较大、或者虽然还没有完成但是希望尽快得到反馈的时候也会直接开一个PR（pull request），并标记为in progress，不过大致的思想没有变，都是需要多人review的。

开源项目这样一个自治的工作流程对我来说无疑是十分新鲜的，它通过code review的形式保证了代码的质量，同时也让每一个人都能自由地进行自己期望的改动（在自己的fork上工作）。这也对代码本身提出了要求，对一个大项目而言，如果不能有效地降低模块间的耦合度的话，那每个patch都将牵涉到许多地方，增加了向这个项目做贡献的门槛（熟悉整个项目），且大大加大了code review的难度，导致这个开源项目很难成长起来。不过这是任何需要长期维护的项目都会存在的问题，有些偏题了。

# Eta

Eta简单来说就是jvm上的Haskell，比较惭愧地说，选择Eta的一大原因是它比较冷门，竞争相对小，不过作为新org它只有两个项目的slot，依然存在许多不确定因素，所幸最后还是被选中了。

## Haskell

Haskell这一门神奇的语言可圈可点的地方很多。作为一门函数式语言，Haskell不像Lisp那样充满了括号，而是通过curry化、infix operator和$、. 等变换函数巧妙地避免了括号使程序相对更加可读（当然读不懂的还是读不懂），再加上许多const、flip等方便的函数存在，使haskeller能写出许多优雅简洁的程序。

ADT的强大也是在Haskell当中初次接触到，使用pattern match基本可以解决所有问题，而链表、字典、树等基础数据结构在Haskell上的实现让我大开眼界，某种意义上又认识到了自己的不足。因为Haskell将pure和不pure的部分完全分开了，一定程度上让我对程序的复杂性有了更深的认识，某种意义上有点害怕IO操作了。

Haskell的lazy、pure、strict都是工业语言不具备的，让人感觉未来的编程语言还有许多发展空间，无论如何它还是一门实验性的语言，学习了Haskell所能提升的可能就是俗称的“内功”吧。

## 阅读源码

在做项目的过程中不可避免地读了许多源码，由此认识到了代码当中注释的重要性，并经历了没有注释看不懂代码、有注释但是没说清楚还是看不懂、自己改了代码之后忘了改注释与别人交流出现问题等一系列问题，真是坎坷啊。阅读源码中最重要的大概就是一个支持跳转到定义功能的编辑器了，掌握各种前跳后跳操作的快捷键也能提高不少效率。

在尝试更改eta-fibers以及debug的过程中基本将Eta的runtime system（rts）的源码读了一遍，其中的scheduler、worker thread等和操作系统里的基本一样，Closure、Exception等的实现也不是那么难，不过我自己还是写不出来。debug的过程是十分痛苦的，因为涉及到多线程，没法用debugger调试，而且是别人犯的错误，不过最后还是过来了。

warp的源码基本就是很普通地读了一下，大致知道所有函数都在做什么，总之就是一个http服务器的实现，haskell的exception与多线程模型使用起来和传统语言其实也差不了多少。源码中有大量注释，所以还是比较好读的。

eta-fibers的两种实现都读了一遍。eta-fibers是cooperative multi-threading，也就是说每个thread都是运行到某个地方自愿yield的，要求yield之后要保留运行信息，这样之后（IO操作完成）才能继续运行。两种实现中一个是用一个额外的stack存储信息，还有一个是用continuation的形式将该thread之后的操作存储在一个Closure当中，个人觉得第二种实现更贴近函数式语言的特点。

## 写代码

实际写的代码比较少，主要就是用non-blocking mode的NIO实现了fiber版本的network库，然后结合该库又将warp里面相关的IO操作都替换了一遍。然后实现了eta-fibers当中的错误处理，这部分做了很多思考，也因为考虑情况不全遇到了一些奇怪的情况，不过最后还是成功了。

过程当中的debug十分艰难，因为没有什么像样的工具，而且涉及到多线程，得到的信息基本上就只有出错/没出错这么1个bit。因为warp本身有不涉及多线程的单元测试，所以用weighttp做benchmark没有错误的话就可以假定没有问题了。总之大部分时间都是用头debug，不知道算不算锻炼了能力

# 总结的总结

GSoC物质上的收获无非就是缩水了的stipend、一件不大可能穿的T恤和可能有用的referal link，完成的这个project可以放在简历上占一个格子。

前面的路还很长，这姑且算是最开始的半步。